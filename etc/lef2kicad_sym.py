#!/usr/bin/env python
from argparse import ArgumentParser
from os       import path, mkdir
from time     import sleep
from enum     import Enum, auto

import datetime
import json
import re
import sys

import tatsu
from jinja2 import Template, Environment

env = Environment(trim_blocks = True, lstrip_blocks = True)
env.globals['now'] = datetime.datetime.utcnow
env.globals['len'] = len

KISYM_TEMPLATE = env.from_string('''\
{#;; SPDX-License-Identifier: BSD-3-Clause #}
{#;; THIS FILE HAS BEEN AUTOGENERATED #}
(kicad_symbol_lib (version 20211014) (generator lef2kicad_sym)
{#  ;; Generated on: {{ now() }} #}
{#  ;;     LEF file: {{ lef_file }} #}
{#  ;;      # Cells: {{ len(symbols) }} #}
{#  ;; Library Name: {{ name }} #}
  {% for sym in symbols %}
  (symbol
{#    ;; Total Pins: {{ sym.pin_count() }} #}
{#    ;; # Pwr Pins: {{ sym.pwr_pins() }} #}
{#    ;; # Gnd Pins: {{ sym.gnd_pins() }} #}
{#    ;; # Inp Pins: {{ sym.inp_pins() }} #}
{#    ;; # Out Pins: {{ sym.out_pins() }} #}
{#    ;; # Iop Pins: {{ sym.iop_pins() }} #}
    "{{ sym.id }}"
    (in_bom no)
    (on_board yes)
    {% for prop in sym.properties %}
    (property
      "{{ prop.name }}"
      "{{ prop.value }}"
      (id {{ prop.id }})
      (at {{ prop.pos[0] }} {{ prop.pos[1] }} {{ prop.pos[2] }})
      (effects
        (font
          (size 1 1)
        )
        {% if prop.justify %}
        (justify top)
        {% endif %}
        {% if prop.hide %}
        hide
        {% endif %}
      )
    )
    {% endfor %}
    {{ sym.get_rect() }}
    {% for pin in sym.pins %}
    (pin
      {{ pin.electrical_type() }}
      {{ pin.graphical_style() }}
      (at {{ pin.pos[0] }} {{ pin.pos[1] }} {{ pin.pos[2] }})
      (length 2.54)
      (name "{{ pin.name }}"
        (effects
          (font
            (size 1 1)
          )
          hide
        )
     )
     (number "{{ pin.number }}"
       (effects
          (font
            (size 1 1)
          )
          hide
        )
      )
    )
    {% endfor %}
  )
  {% endfor %}
)
''')

class Property:
	def __init__(self, name, value, pid, hide = True):
		self.name = name
		self.value = value
		self.id = pid
		self.hide = hide
		self.pos = (0, 0, 0)
		self.justify = False

	def __str__(self):
		return __repr__()

	def __repr__(self):
		return f'(property "{self.name}" "{self.value}" (id {self.id}))'

class Cell:
	def _count_pins(self):
		pwr = 0
		gnd = 0
		inp = 0
		out = 0
		iop = 0

		for pin in self.pins:
			if pin.type == PinType.POWER:
				pwr += 1
			elif pin.type == PinType.GROUND:
				gnd += 1
			elif pin.type == PinType.SIGNAL or pin.type == PinType.CLOCK:
				if pin.dir == PinDir.INPUT:
					inp += 1
				elif pin.dir == PinDir.OUTPUT:
					out += 1
				elif pin.dir == PinDir.BIDIRECTIONAL:
					iop += 1

		self._pin_counts = (pwr, gnd, inp, out, iop)

	def _calc_bounds(self):
		hpad = 0
		wpad = 0

		for pin in self.pins:
			nlen = len(pin.name)
			if pin.type == PinType.POWER or pin.type == PinType.GROUND:
				hpad = max(hpad, nlen)
			else:
				wpad = max(wpad, nlen)

		hpad *= 1.27
		wpad *= 1.27

		self._padding = (wpad, hpad)

		width = (max(self._pin_counts[0], self._pin_counts[1]) * 2.54) + 2.54
		x = width / 2

		lheight = self._pin_counts[2]
		rheight = self._pin_counts[3]

		hdiff = lheight - rheight

		iops = self._pin_counts[4]
		io_fixup = min(abs(hdiff), iops)

		if hdiff < 0:
			lheight += io_fixup
		else:
			rheight += io_fixup

		iops -= io_fixup

		lheight += iops // 2
		rheight += iops - (iops // 2)

		height = (max(lheight, rheight) * 2.54) + 2.54
		y = height / 2

		return (-x - wpad, -y - hpad, x + wpad, y + hpad)

	def _fixup_pins(self):
		x0, y0, x1, y1 = self._bounds

		pin_idx = 0
		for pin in self.pins:
			if pin.type == PinType.POWER:
				pin.set_y(y1 + 2.54)
				pin.set_x(x0 + (2.54 * (pin_idx +1)) + self._padding[0])
				pin.set_rot(270)
				pin_idx += 1

		pin_idx = 0
		for pin in self.pins:
			if pin.type == PinType.GROUND:
				pin.set_y(y0 - 2.54)
				pin.set_x(x0 + (2.54 * (pin_idx +1)) + self._padding[0])
				pin.set_rot(90)
				pin_idx += 1

		pin_idx = 0
		inp_y = y0 + 2.54
		for pin in self.pins:
			if (pin.type == PinType.SIGNAL or pin.type == PinType.CLOCK) and pin.dir == PinDir.INPUT:
				pin.set_x(x0 - 2.54)
				inp_y = (y1 - (2.54 * (pin_idx + 1)) - self._padding[1])
				pin.set_y(inp_y)
				pin_idx += 1

		pin_idx = 0
		out_y = y0 + 2.54
		for pin in self.pins:
			if (pin.type == PinType.SIGNAL or pin.type == PinType.CLOCK) and pin.dir == PinDir.OUTPUT:
				pin.set_x(x1 + 2.54)
				out_y = (y1 - (2.54 * (pin_idx + 1)) - self._padding[1])
				pin.set_y(out_y)
				pin.set_rot(180)
				pin_idx += 1


		iop_remaining = abs(self._pin_counts[2] - self._pin_counts[3])

		rot = 0
		for pin in self.pins:
			if pin.type == PinType.SIGNAL or pin.type == PinType.CLOCK:
				if pin.dir == PinDir.BIDIRECTIONAL or pin.dir == PinDir.PASSIVE:
					if iop_remaining > 0:
						if inp_y < out_y:
							pin.set_x(x1 + 2.54)
							pin.set_rot(180)
						else:
							pin.set_x(x0 - 2.54)
							pin.set_rot(0)


						pin.set_y(min(inp_y, out_y) + 2.54)

						if inp_y < out_y:
							inp_y += 2.54
						else:
							out_y += 2.54

						iop_remaining -= 1
					else:
						if rot == 0:
							pin.set_x(x0 - 2.54)
							pin.set_y(inp_y)
							pin.set_rot(rot)
							inp_y += 2.54
							rot = 180
						else:
							pin.set_x(x1 + 2.54)
							pin.set_y(out_y)
							pin.set_rot(rot)
							out_y += 2.54
							rot = 0

	def _fixup_properties(self):
		for prop in self.properties:
			if prop.name == 'Value':
				prop.pos = (self._bounds[0], self._bounds[1], 0)
				prop.justify = True


	def __init__(self, name, pins, lef_file_name = '', bounds = (0.0, 0.0)):
		self.id = name
		self.pins = pins
		self._pin_counts = None
		self._count_pins()
		self._padding = (0, 0, 0, 0)
		self._bounds = self._calc_bounds()

		self._fixup_pins()

		self.properties = [
			Property('Reference', 'CELL',        0),
			Property('Value',     name,          1, False),
			Property('Footprint', f'{bounds}',   2),
			Property('Datasheet', lef_file_name, 3)
		]

		self._fixup_properties()

	def get_rect(self):
		return f'''\
(rectangle
      (start {self._bounds[0]} {self._bounds[1]})
      (end {self._bounds[2]} {self._bounds[3]})
      (stroke
        (width 0.1)
        (type solid)
        (color 0 0 0 0)
      )
      (fill
        (type background)
      )
    )'''

	def pin_count(self):
		return len(self.pins)

	def pwr_pins(self):
		return self._pin_counts[0]

	def gnd_pins(self):
		return self._pin_counts[1]

	def inp_pins(self):
		return self._pin_counts[2]

	def out_pins(self):
		return self._pin_counts[3]

	def iop_pins(self):
		return self._pin_counts[4]

	def __str__(self):
		return self.__repr__()

	def __repr__(self):
		return f'(cell "{self.id}" {" ".join(map(str, self.pins))})'

class PinDir(Enum):
	INPUT         = auto()
	OUTPUT        = auto()
	TRISTATE      = auto()
	BIDIRECTIONAL = auto()
	PASSIVE       = auto()
	UNSPECIFIED   = auto()

	def __str__(self):
		if self == PinDir.INPUT:
			return 'input'
		elif self == PinDir.OUTPUT:
			return 'output'
		elif self == PinDir.TRISTATE:
			return 'tristate'
		elif self == PinDir.BIDIRECTIONAL:
			return 'bidirectional'
		elif self == PinDir.PASSIVE:
			return 'passive'
		else:
			return 'unspecified'

	@staticmethod
	def from_str(s):
		if s is None:
			return PinDir.BIDIRECTIONAL

		normalized = s.lower()

		if normalized == 'input':
			return PinDir.INPUT
		elif normalized == 'output':
			return PinDir.OUTPUT
		elif 'tristate' in normalized:
			return PinDir.TRISTATE
		elif normalized == 'bidirectional' or normalized == 'inout':
			return PinDir.BIDIRECTIONAL
		elif normalized == 'passive' or normalized == 'feedthru':
			return PinDir.PASSIVE
		else:
			return PinDir.UNSPECIFIED

class PinType(Enum):
	SIGNAL = auto()
	POWER  = auto()
	GROUND = auto()
	CLOCK  = auto()

	def __str__(self):
		if self == PinType.POWER:
			return 'power'
		elif self == PinType.GROUND:
			return 'ground'
		elif self == PinType.CLOCK:
			return 'clock'
		else:
			return 'signal'

	@staticmethod
	def from_str(s):
		if s is None:
			return PinType.SIGNAL
		normalized = s.lower()

		if normalized == 'power':
			return PinType.POWER
		elif normalized == "ground":
			return PinType.GROUND
		elif normalized == 'clock':
			return PinType.CLOCK
		else:
			return PinType.SIGNAL

class Pin:
	def __init__(self, name, d, typ, num = 0):
		self.name = name
		self.number = num
		self.dir = PinDir.from_str(d)
		self.type = PinType.from_str(typ)
		self.pos = (0, 0, 0)

	def set_x(self, x):
		self.pos = (x, self.pos[1], self.pos[2])

	def set_y(self, y):
		self.pos = (self.pos[0], y, self.pos[2])

	def set_rot(self, r):
		self.pos = (self.pos[0], self.pos[1], r)

	def electrical_type(self):
		if self.type == PinType.POWER or self.type == PinType.GROUND:
			return 'power_in'
		else:
			if self.dir == PinDir.INPUT:
				return 'input'
			elif self.dir == PinDir.OUTPUT:
				return 'output'
			elif self.dir == PinDir.TRISTATE:
				return 'tristate'
			elif self.dir == PinDir.BIDIRECTIONAL:
				return 'bidirectional'
			elif self.dir == PinDir.PASSIVE:
				return 'passive'
			else:
				return 'unspecified'

	def graphical_style(self):
		if self.is_clk():
			return 'clock'
		elif self.is_inverted():
			return 'inverted'
		else:
			return 'line'

	def is_clk(self):
		return self.type == PinType.CLOCK

	def is_inverted(self):
		return self.name.lower().split('_')[-1] in ('bar', 'n')

	def __str__(self):
		return self.__repr__()

	def __repr__(self):
		return f'(pin "{self.name}" {self.type} {self.dir})'

def extract_cells(model, lef_file, lib_name, lef_file_name, args):
	ignore_pwr = args.ignore_pwr

	print(f'Parsing {lef_file_name}')
	with open(lef_file, 'r') as lef:
		ast = model.parse(''.join(lef.readlines()))

	cells = []
	if args.infer_pwr:
		print(' NOTE: Attempting to infer power pins based on name')
	print(f' => Looking for cell macros')
	for i in ast[0]:
		if 'macro' in i:
			m = i['macro']

			raw_name = ''.join(m['name'][0])
			if '__' in raw_name:
				cell_name = raw_name.split('__')[1]
			else:
				cell_name = raw_name
			pins = []
			ignored_pins = 0

			print(f'  => Found cell \'{cell_name}\', looking for pins')

			for stmt in m['mstmts']:
				if 'pin' in stmt:
					pin = stmt['pin']
					flattened_name = [i for sl in list(pin['name']) for i in sl]
					pin_name = ''.join(flattened_name)
					pin_dir = None
					pin_type = None

					for pstmt in pin['pstmnts']:
						if 'dir' in pstmt:
							pin_dir = pstmt['dir']['pin_dir']
						if 'use' in pstmt:
							pin_type = pstmt['use']['pin_type']

					if args.infer_pwr and pin_type is None:
						if 'vss' in pin_name.lower():
							pin_type = 'GROUND'
						elif 'vdd' in pin_name.lower():
							pin_type = 'POWER'

					if ignore_pwr:
						if pin_type == 'GROUND' or pin_type == 'POWER':
							ignored_pins += 1
							continue
					pins.append(Pin(
						pin_name, pin_dir, pin_type, num = len(pins)
					))
			print(f'  => Found {len(pins)} pins in cell \'{cell_name}\'')
			if ignore_pwr:
				print(f'  => Ignored {ignored_pins} power pins')
			cells.append(Cell(
				cell_name, pins, lef_file_name
			))
	print(f' => Found {len(cells)} cell macros in {lef_file_name}')
	return {
		'name': lib_name,
		'lef_file': lef_file_name,
		'cells': cells
	}


def process(model, lef_file, args):
	outdir = args.outdir

	lef_file_name = path.basename(lef_file)
	lib_name = path.splitext(lef_file_name)[0]
	kisym_name = f'{lib_name}.kicad_sym'
	outfile = path.join(outdir, kisym_name)


	if args.skip_existing and path.exists(outfile):
		print(f'Skipping {kisym_name} as it already exists')
		return

	lib = extract_cells(model, lef_file, lib_name, lef_file_name, args)


	print(f'Generating \'{kisym_name}\' in {outdir} from {lef_file_name}')

	symfile = KISYM_TEMPLATE.render(
		name     = lib['name'],
		lef_file = lib['lef_file'],
		symbols  = lib['cells'],
	)

	print(f' => Writing {kisym_name}')
	with open(outfile, 'w') as sym:
		sym.write(symfile)
		sym.write('\n')


def main():
	with open('lef.tatsu', 'r') as f:
		lef_grammar = f.readlines()
	print('Compiling TatSu parser')
	model = tatsu.compile(''.join(lef_grammar))

	parser = ArgumentParser(description="Generate KiCad symbol library from LEF files")

	parser.add_argument(
		'lef_files',
		nargs    = '+',
		help     = 'LEF files to parse into kicad_sym files'
	)

	parser.add_argument(
		'--outdir', '-o',
		type    = str,
		default = '.',
		help    = 'output directory for kicad_sym files'
	)

	parser.add_argument(
		'--ignore-pwr', '-I',
		action = 'store_true',
		help   = 'Ignore power pins from cells'
	)

	parser.add_argument(
		'--infer-pwr', '-i',
		action = 'store_true',
		help   = 'try to infer power signals based on name id pin has no type'
	)

	parser.add_argument(
		'--skip-existing', '-S',
		action = 'store_true',
		help   = 'Skip ingestion and parsing of a LEF file if the .kicad_sym file already exists'
	)

	args = parser.parse_args()

	for lef_file in args.lef_files:
		process(model, lef_file, args)

	return 0


if __name__ == '__main__':
	sys.exit(main())
